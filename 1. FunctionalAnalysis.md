1. Functional Analysis
 # **Maya - Functional Description (Current / AS‑IS)**

Goal of this document

This document explains **how Tasks work today** in Maya (what the user can do, what the system does, how it behaves in edge cases), with enough detail for a developer with **zero context** to reason about expected behavior and troubleshoot issues.

Scope

- “Tasks” (daily schedule / day plan)
- “Nutritional Inputs / Spraying” (separate feature but shown together in schedule/calendar views)
- Dependencies in the **functional sense**:
    - what a task depends on (sites/areas/actions/staff/machines/products)
    - how tasks are grouped (merge_key)
    - how tasks relate internally (parent/child rows)
    - what side-effects happen (inventory ledger, TOIL)

Out of scope

- The ideal future unified model (see `02_technical_as-is_to-be_strategy.md`).

---

## **1. Glossary (Domain Terms)**

These terms are used across backend (`core-2.0`) and frontend (`web`).

### **1.1 Tenant vs Group**

These two terms represent the same customer at different layers of the system.

| Layer | Term | Purpose |
| --- | --- | --- |
| UI / API | **Tenant** | What the frontend and API calls use to identify "which customer" |
| Database | **Group** | The actual partition key stored in scheduling tables (`task.idgroup`) |

**Relationship: One tenant → Many groups**

A single tenant (customer) can have multiple groups (departments, teams, divisions):

```
Tenant: "Golf Course ABC"
  ├── Group: "Main Operations" (default)  ← iddefault_group points here
  ├── Group: "Maintenance Team"
  └── Group: "Groundskeeping"

```

**How resolution works:**

1. Frontend sends `idtenant` in API requests
2. Backend looks up the tenant and retrieves `tenant.iddefault_group`
3. Database queries filter by `idgroup` (not `idtenant`)

```
Frontend:  GET /schedules?idtenant=abc-123
                    ↓
Backend:   Tenant abc-123 → default group xyz-789
                    ↓
Database:  SELECT * FROM task WHERE idgroup = 'xyz-789'

```

**Key code location:** `AdminService.php` → `findGroupForTenant()` performs this resolution.

**Why this matters for developers:**

- If you see `idgroup` in SQL but `idtenant` in API calls, they refer to the same customer at different layers
- Most schedule operations automatically use the tenant's **default group**
- The `task` table is partitioned by `idgroup`, not `idtenant`

### **1.2 Site, Hole, Area (Tag)**

- **Site**: A top-level location.
    - *Golf context:* A "Course" (e.g., "North Course").
    - *Football context:* A "Complex" or the "Stadium".
- **Hole / Sub-site**: A specific sub-unit of a site.
    - *Golf context:* "Hole 1", "Hole 2", etc.
    - *Football context:* "Pitch 1", "Training Ground", "Stadium Pitch".
- **Area / Tag**: Granular work zones.
    - *Golf context:* "Greens", "Fairways", "Tees".
    - *Football context:* "Goal Mouth Area", "Center Circle", "Sidelines".

In the current system, *areas are attached to tasks via “taggables”*:

- Each task row can have multiple tags.
- When a schedule is created, tags can be duplicated across all rows in the schedule group.

### **1.3 Action**

An **Action** is the “what” of the task (mowing, topdressing, aeration…). Technically, schedule tasks store an `idaction`.

### **1.4 Task (UI concept) vs Task (DB row)**

This is one of the biggest sources of confusion:

- **Task (UI logical item)**: what a user thinks of as a single scheduled job.
- **Task (DB row)**: a row in the legacy `task` table.

In AS‑IS, a single UI logical task is often represented by **multiple DB rows**, tied together by a shared `merge_key`.

### **1.5 merge_key**

`merge_key` is a long string used as the *primary grouping identifier* for schedule tasks.

- The UI generates it and sends it when creating/updating tasks.
- The backend also uses it as the grouping key when deleting schedules and linking products.

Functional meaning:

- “All task DB rows with the same merge_key belong to the same logical schedule entry (or cluster of entries).”

Important: for multi-site / multi-hole jobs, you can have **multiple parent rows** (each with its own `idsite`) but still share the same `merge_key`.

### **1.6 Parent task vs sub tasks (staff/machinery)**

The `task` table is used for both a “parent” schedule record and its “sub tasks”:

- **Parent task**: `idparent_task` is NULL.
- **Child task**: `idparent_task` points to the parent row.

Children are used to model:

- **Staff assignments**: child rows with `idstaff` set.
- **Machinery assignments**: child rows with `idmachinery` set.

---

## **2. What users can do (Current capability set)**

### **2.1 Create a schedule task (Day plan)**

A user creates a task by selecting:

- date (the day plan date)
- action
- site(s) and optionally holes
- area(s)
- staff list (required by API)
- optionally machines list
- planned start/end or planned duration (`estimate_time`)
- optional note
- flags: AM/PM/overtime

System result (high level):

- The UI creates a **merge_key**.
- The backend writes into:
    - `task` table: a parent row plus child rows for staff and machines
    - `taggable` table: rows linking areas/tags to tasks

### **2.2 Edit a schedule task**

A user can edit:

- action, time, duration, note
- selected sites/holes
- staff / machinery assignments
- areas (tags)

Key functional detail:

- If action or the site/hole selection changes, the UI may generate a **new merge_key**, and the backend will update the schedule and also propagate the merge_key change into product links.

### **2.3 Delete a schedule task**

Two modes exist:

- **Delete by merge_key** (delete the whole schedule cluster)
- **Delete a single task row** (delete a specific parent row and its children)

In the UI, deletion by merge_key is the common “delete schedule” behavior.

### **2.4 Mark a task “completed” (running toggle)**

Completion is represented mainly by:

- `running` flag + `task_start`/`task_end` timestamps

A key side-effect:

- When products are linked to the task, flipping `running` from 0 → 1 can trigger **inventory ledger changes**.

### **2.5 Link products to tasks**

Products can be added/edited for a schedule (identified by merge_key):

- The UI calls a tasks/products endpoint with `{ merge_key, products[] }`.
- Products are stored in `product_task`.

### **2.6 Manage “Nutritional Inputs / Spraying”**

Spraying is a separate feature with its own table (`spraying`) and endpoints.

However, some schedule/calendar views combine “Tasks” and “Spraying” into a single list per day.

### **2.7 Record TOIL / Overtime**

There are (at least) two functional routes for TOIL in the current UI and code:

1. Explicit TOIL creation from the schedule UI
- The frontend can create TOIL entries per staff member as part of saving an edit.
1. Intended backend automation (event-driven)
- Backend dispatches `ScheduleOperation` events on schedule create/update/delete.
- A listener `CreateToilRecordListener` exists.

⚠️ Current operational reality:

- In `core-2.0`, `EventServiceProvider` currently has an empty `$listen` map and `shouldDiscoverEvents()` returns false.
- That means the `CreateToilRecordListener` is **not wired** by default.
- So event-driven TOIL creation may not run unless the project registers the listener elsewhere (not present in the repo as checked).

Implication for a developer:

- If TOIL is “mysteriously not being created” when scheduling overtime tasks, check the event wiring first.

---

## **3. The current “Task” data model (Functional view)**

### **3.1 Core fields the UI relies on**

A schedule record is effectively identified by:

- `merge_key` (grouping)
- `idaction` (what)
- `idsite` (where)
- date / time fields (`createdon`, `task_start`, `task_end`)
- flags (`is_am`, `is_pm`, `is_over_time`)
- `estimate_time` (planned duration)
- `note`

The DB also stores:

- `task_parameters` (JSON string used for task-specific details)
- recurrence fields (`recurrent`, `recurrence_rule`, `next_execution`, `last_execution`) — not always used in the day plan UI.

### **3.2 Parent row + children rows**

When a schedule is created, the backend creates:

1. One parent row:
- `idparent_task = NULL`
- has `idsite`, `idaction`, timing, flags, merge_key, etc.
1. Staff child rows (0..N):
- `idparent_task = <parent.idtask>`
- `idstaff = <staff uuid>`
1. Machinery child rows (0..N):
- `idparent_task = <parent.idtask>`
- `idmachinery = <machine uuid>`

Functional consequence:

- Staff and machine “assignments” are not modeled as junction rows; they are modeled as **duplicate rows in the same task table**.

### **3.3 Areas (tags) attachment**

Areas are attached by inserting rows into `taggable`:

- In create, tags are created for the parent and for each child task id.
- In update, tags are deleted for the affected idtasks and reinserted.

Functional consequence:

- Areas can appear on child task rows.
- Some API read methods may attach areas differently depending on whether they attach tags to parent only or to children.

---

## **4. The merge_key (How grouping works)**

### **4.1 merge_key generation (Frontend)**

The schedule UI generates merge_key when saving new tasks and sometimes when editing existing ones.

Observed behavior (from `web/src/composables/formatting/schedule/scheduleSaveTasks.js`):

- If action or the set of sites/holes changes, `merge_key` is recomputed.
- The UI concatenates:
    - all selected site IDs (without dashes)
    - all selected hole IDs (without dashes) when only one site is selected
    - action ID (without dashes)
    - the current schedule date in `YYYYMMDD`
    - plus a time/random component inside `generateMergedKey(...)`

### **4.2 merge_key usage patterns**

- **Create schedule**: merge_key is required.
- **Update schedule**:
    - request uses query params `mergeKey=<current>` and optional `newMergeKey=<next>`
    - body contains the schedule fields.
    - backend updates tasks of a specific parent/cluster and can also propagate product links to the new merge key.
- **Delete schedule**:
    - delete by merge_key deletes all task rows having that merge_key and their taggables.

### **4.3 merge_key as “dependency”**

From a functional standpoint, merge_key is the system’s main *dependency hook*:

- Product links depend on merge_key (`product_task.merge_key_hash`).
- Inventory ledger changes for tasks depend on merge_key.
- Delete-by-mergeKey deletes the entire cluster.

If merge_key changes:

- Product links must be migrated to the new merge_key (backend does this on update).
- Any external references that store merge_key (reports, inventory) need careful handling.

---

## **5. Task status semantics (What “running” means)**

### **5.1 State fields involved**

- `task_start`: timestamp, may be null
- `task_end`: timestamp, may be null
- `running`: numeric/boolean flag
- `status`: numeric state (present, but many parts of the UI use `running + start/end`)

### **5.2 Sorting key used by schedule list**

Backend computes a `sortingKey` string:

```
sortingKey = (task_start ? '1' : '0') + (task_end ? '1' : '0') + (running ? '1' : '0')

```

Then it maps the sortingKey to an order bucket:

- `000` → “todo”
- `100` → “in progress (started, no end)”
- `110` or `010` → “ended”
- `111` or `001` → “completed/running”

Important: the mapping is legacy and not perfectly aligned with the human meaning of “running”.

### **5.3 Inventory side-effect on completion**

When products are attached to a schedule:

- If the task is toggled from `running = 0` to `running = 1`, the system creates inventory ledger entries (negative amounts) for each product quantity.
- If toggled back from `running = 1` to `running = 0`, the system creates ledger entries that revert the consumption.

This only happens when:

- The schedule update endpoint is used and it detects a running transition.

---

## **6. Products and inventory (Functional dependency chain)**

### **6.1 Linking products to tasks**

Products are linked by merge_key (not by idtask):

- Link table: `product_task`
- Index workaround: `product_task.merge_key_hash = sha256(merge_key)`

Functional consequence:

- Products attach to the whole logical schedule cluster (merge_key), not to a specific parent task row.
- Changing merge_key requires migrating these product links.

### **6.2 Inventory ledger behavior**

Inventory entries are created in `inventory_ledger`:

- For schedule tasks: ledger rows reference `merge_key`
- For spraying: ledger rows reference `idspraying`

Functional consequence:

- Schedule consumption tracking is grouped by merge_key.
- Spraying consumption tracking is grouped by spraying ID.

---

## **7. Dependencies and integrations (Current)**

This section is the “what does scheduling depend on” map.

### **7.1 Backend service dependencies when fetching tasks**

When tasks are fetched for a tenant and date, the backend enriches tasks with:

- tags/areas (taggable)
- machine incidents
- TOIL records

This means the schedule UI is not just reading `task`; it depends on several subsystems being coherent.

### **7.2 Legacy / cross-module dependencies (Fleet, lookup data)**

Even though tasks themselves are mostly served from `core-2.0`, other schedule-adjacent screens can depend on legacy Core 1 (OData) for:

- product categories
- some unit lookup
- fleet/machine metadata

In practice (based on frontend usage), Core 1 dependencies around scheduling are broader than just “fleet”:

- **Schedule admin/meta**: action CRUD, task reminders, staff update, leaves/working-days helper
- **TOIL**: listing and patching TOIL/overtime entries
- **Spraying lookups**: product_category and nozzle/unit lookup
- **Weather/devices**: site/device OData entities + weather chart/export helpers
- **Stock management**: stock types, inventory views, inventory ledger writes, product documents

How the frontend chooses Core 1 vs Core 2.0:

- The axios wrapper in `web/src/store/axios-config.js` switches base URL when `{ useLegacyApi: true }` is passed.
- Core 1 routes are served under `/api/odata/v1/*` in the legacy backend; the frontend usually calls paths like `/product_category?...` and relies on `VITE_API_URL` to include the `/api/odata/v1` prefix.

A developer working on schedule often needs to know whether a data gap is due to:

- missing `core-2.0` endpoint
- a legacy Core 1 call (and CORS/auth) problem

---

## **8. Key API surface (Current)**

### **8.1 Schedule tasks**

- `POST /createSchedule`
    - Creates a schedule cluster (parent + children rows)
    - Requires `sub_tasks.staffs` and `areas`

### **8.1.1 Create schedule — payload contract (as validated by backend)**

The backend validates create payload using `ScheduleCreateRequest`.

Minimum required fields (practically):

- `task_type`: `"site-based" | "tenant-based"`
- `idgroup`, `iduser`, `idsite`, `idaction`: UUID strings
- `merge_key`: string
- `createdon`: datetime string
- `estimate_time`: integer minutes (or minutes-like integer used by UI)
- `name`: string
- `sub_tasks.staffs`: array of staff UUIDs (required)
- `areas`: array of area/tag UUIDs (required)

Other frequently used fields:

- `task_start`, `task_end`: nullable datetime
- `note`: string
- `is_am`, `is_pm`, `is_over_time`: boolean-ish
- `sub_tasks.machineries`: array of machinery UUIDs
- `overtime_duration`: integer minutes

Example JSON (simplified):

```json
{
  "task_type": "site-based",
  "idgroup": "<group-uuid>",
  "iduser": "<creator-user-uuid>",
  "idsite": "<site-uuid>",
  "idaction": "<action-uuid>",
  "merge_key": "<generated-merge-key>",
  "createdon": "2025-12-22 00:00:00",
  "name": "Aeration",
  "estimate_time": 180,
  "task_start": "2025-12-22 08:00:00",
  "task_end": "2025-12-22 11:00:00",
  "note": "Focus on greens",
  "is_am": true,
  "is_pm": false,
  "is_over_time": false,
  "areas": ["<tag-uuid-1>", "<tag-uuid-2>"],
  "sub_tasks": {
    "staffs": ["<staff-uuid-1>", "<staff-uuid-2>"],
    "machineries": ["<machine-uuid-1>"]
  }
}

```

- `PUT /update-schedule?mergeKey=<current>&newMergeKey=<optional>`
    - Updates tasks under a merge_key in the context of a parent task
    - Can add/remove staff and machines by creating/deleting child rows
    - Rewrites taggables
    - Migrates `product_task` merge_key when merge_key changes
    - May trigger inventory changes if `running` toggles

### **8.1.2 Update schedule — payload contract (as validated by backend)**

The backend validates update payload using `UpdateTaskRequest`.

Important details:

- The HTTP query string carries `mergeKey` and optional `newMergeKey`.
- The request body must include enough information to re-write the schedule fields.
- `sub_tasks` is accepted as an object, and (in practice) should include:
    - `staffs`: array of UUIDs
    - `machineries`: array of UUIDs
- `areas` is an array of UUIDs.

Example JSON (simplified):

```json
{
  "task_type": "site-based",
  "idgroup": "<group-uuid>",
  "idsite": "<site-uuid>",
  "idaction": "<action-uuid>",
  "name": "Aeration",
  "task_start": "2025-12-22 08:00:00",
  "task_end": "2025-12-22 11:00:00",
  "estimate_time": 180,
  "note": "Updated note",
  "running": 1,
  "is_am": 1,
  "is_pm": 0,
  "is_over_time": 0,
  "areas": ["<tag-uuid-1>", "<tag-uuid-2>"],
  "sub_tasks": {
    "staffs": ["<staff-uuid-1>", "<staff-uuid-2>", "<staff-uuid-3>"],
    "machineries": ["<machine-uuid-1>"]
  },
  "callerId": "<user-uuid>",
  "defaultGroupId": "<group-uuid>",
  "tenantId": "<tenant-uuid>"
}

```

Notes:

- `callerId/defaultGroupId/tenantId` are required for inventory ledger writes when products exist and `running` transitions.
- The update endpoint updates a set of task rows (parent + children) in the merge_key group, scoped by a parent task id.
- `DELETE /schedule/<mergeKey>`
    - Deletes all tasks having the merge_key and deletes taggables for those idtasks
- `DELETE /schedule/task/<taskId>`
    - Deletes one parent task, its children, and related taggables
- `GET /schedules?idtenant=<tenant>&start_date=<YYYY-MM-DD>&end_date=<YYYY-MM-DD>`
    - Returns a merged view of tasks and spraying for calendar by date

### **8.2 Products**

- `POST /tasks/products`
- `PUT /tasks/products`

Payload shape:

```json
{
  "merge_key": "...",
  "products": [
    { "idproduct": "uuid", "quantity": 12.5 }
  ]
}

```

Important validation detail:

- The backend requires `merge_key` to already exist in the `task` table (it uses `exists:task,merge_key`).
- Therefore, linking products to a merge_key that was never persisted (or was deleted) will fail validation.

### **8.3 Spraying**

- `GET /getSprayingRecords?idtenant=...&start_date=...&end_date=...`
- `POST /createSprayingRecords`
- `DELETE /deleteSprayingRecords` (request payload contains `idspraying`)

### **8.4 Core 1 (Legacy) endpoints the schedule experience still depends on**

These are called by the frontend with `{ useLegacyApi: true }` and are served by Core 1’s OData gateway.

Schedule-adjacent:

- `POST /updateStaff`
- `POST /action`, `PATCH /action(...)`
- `POST /task_reminder`, `PATCH /task_reminder(...)`
- `POST /getLeavesandWorkingdaysByUsers`

Spraying lookups:

- `GET /product_category?...`
- `GET /unit?...`

TOIL:

- `GET /toil?...` and `PATCH /toil(...)`

Fleet:

- `GET /getMachineData(...)`, `GET /getMachineDataByMachine(...)`

Weather:

- `POST /weatherChartData`, `POST /exportWeatherData`
- `GET /site?...$expand=devices...`, `GET /device(...)...`

---

## **9. Known functional pitfalls (Current)**

These are common sources of “this looks wrong” reports from users.

1. One logical task = multiple DB rows
- Developers often query `task` and think they found duplicates. Most of the time it’s deliberate (staff/machine children) or multi-site parent rows.
1. merge_key changes can “split” history
- If the UI regenerates merge_key on edit, product links and inventory grouping move to the new merge_key. If anything fails mid-update, history can look fragmented.
1. Calendar view uses created date, not always planned start
- Some calendar aggregation queries group by `DATE(parent.createdon)` instead of `task_start`. This can shift items if created date differs from planned date.
1. TOIL automation may not run
- The code contains an event + listener, but the listener is not registered by default in the repo.

---

## **10. Where to look in code (Quick map)**

Backend (core-2.0):

- `app/Http/Controllers/ScheduleController.php`
- `app/Repositories/ScheduleRepository.php`
- `app/Services/ScheduleService.php`
- `app/Services/StockService.php` (inventory side-effects)
- `app/Http/Controllers/SprayingController.php`

Frontend (web):

- `src/store/schedule/index.js` (API calls)
- `src/composables/formatting/schedule/scheduleSaveTasks.js` (merge_key generation, create/edit behavior)

---

## **Appendix A — Minimal “mental model” examples**

### **A.1 Single-site task**

**Golf Example**: User creates "Aeration" for "North Course". **Football Example**: User creates "Mowing" for "Training Pitch 1".

- 2 staff assigned, 1 machine.

DB (conceptually):

- 1 parent row (Site S1)
- 2 child staff rows
- 1 child machine row
- All 4 share the same merge_key.

### **A.2 Multi-site task**

**Golf Example**: User selects "North Course" AND "South Course" for "Overseeding". **Football Example**: User selects "Stadium Pitch" AND "Training Pitch 1" for "Fertilizing".

Behavior:

- UI sends separate create calls per site selection but with the same merge_key.
- DB ends up with at least 2 parent rows (one per site), plus their children.

Functional consequence:

- Delete by merge_key deletes both sites’ schedule entries.
- Update may operate per parent row depending on UI flow.